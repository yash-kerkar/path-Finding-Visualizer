{"ast":null,"code":"export function dijkstra(grid,startNode,finishNode){console.log(finishNode);var visitedNodesInOrder=[];startNode.distance=0;var unvisitedNodes=getAllNodes(grid);var i=0;while(i<unvisitedNodes.length){sortNodesByDistance(unvisitedNodes);var minNode=unvisitedNodes.shift();if(minNode.distance===Infinity)return[visitedNodesInOrder,null];if(minNode.isWall||minNode.isBorder)continue;minNode.isVisited=true;visitedNodesInOrder.push(minNode);console.log(finishNode);if(minNode===finishNode)return[visitedNodesInOrder,findPath(finishNode)];updateNeighbours(minNode,grid);}}function getAllNodes(grid){var temp=[];for(var i=0;i<grid.length;i++){for(var j=0;j<grid[i].length;j++){if(!grid[i][j].isVisited){temp.push(grid[i][j]);}}}return temp;}function sortNodesByDistance(unvisitedNodes){unvisitedNodes.sort(function(nodeA,nodeB){return nodeA.distance-nodeB.distance;});}function updateNeighbours(node,grid){var row=node.row,col=node.col;if(row>0&&grid[row-1][col].isVisited!==true&&grid[row-1][col].distance>node.distance+1){grid[row-1][col].distance=node.distance+1;grid[row-1][col].parentNode=node;}if(row<grid.length-1&&grid[row+1][col]!==true&&grid[row+1][col].distance>node.distance+1){grid[row+1][[col]].distance=node.distance+1;grid[row+1][col].parentNode=node;}if(col>0&&grid[row][col-1]!==true&&grid[row][col-1].distance>node.distance+1){grid[row][col-1].distance=node.distance+1;grid[row][col-1].parentNode=node;}if(col<grid[0].length-1&&grid[row][col+1]!==true&&grid[row][col+1].distance>node.distance+1){grid[row][col+1].distance=node.distance+1;grid[row][col+1].parentNode=node;}}function findPath(finishNode){var temp=[];while(finishNode.isStart!==true){temp.push(finishNode.parentNode);finishNode=finishNode.parentNode;}return temp.reverse();}","map":{"version":3,"sources":["C:/Users/YASH/path-find-visualizer/src/algorithms/dijkstra.js"],"names":["dijkstra","grid","startNode","finishNode","console","log","visitedNodesInOrder","distance","unvisitedNodes","getAllNodes","i","length","sortNodesByDistance","minNode","shift","Infinity","isWall","isBorder","isVisited","push","findPath","updateNeighbours","temp","j","sort","nodeA","nodeB","node","row","col","parentNode","isStart","reverse"],"mappings":"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","sourcesContent":["\r\nexport function dijkstra(grid,startNode,finishNode){\r\n    console.log(finishNode)\r\n    const visitedNodesInOrder = []\r\n    startNode.distance = 0\r\n    const unvisitedNodes = getAllNodes(grid);\r\n    let i = 0;\r\n    while(i < unvisitedNodes.length){\r\n        sortNodesByDistance(unvisitedNodes);\r\n        const minNode = unvisitedNodes.shift()\r\n        if(minNode.distance === Infinity) return [visitedNodesInOrder,null]\r\n        if(minNode.isWall || minNode.isBorder) continue\r\n        minNode.isVisited = true\r\n        visitedNodesInOrder.push(minNode)\r\n        console.log(finishNode)\r\n        if(minNode === finishNode) return [visitedNodesInOrder,findPath(finishNode)]\r\n        updateNeighbours(minNode,grid)\r\n    }\r\n\r\n}\r\n\r\nfunction getAllNodes(grid){\r\n    let temp = []\r\n    for(let i=0; i < grid.length; i++){\r\n        for(let j=0; j <grid[i].length; j++){\r\n            if(!grid[i][j].isVisited){\r\n                temp.push(grid[i][j])\r\n            }\r\n        }\r\n    }\r\n    return temp\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes){\r\n    unvisitedNodes.sort((nodeA,nodeB)=>nodeA.distance - nodeB.distance)\r\n}\r\n\r\nfunction updateNeighbours(node,grid){\r\n    const {row,col} = node;\r\n    if(row > 0 && grid[row-1][col].isVisited !== true && grid[row-1][col].distance > node.distance + 1){\r\n        grid[row-1][col].distance = node.distance + 1;\r\n        grid[row-1][col].parentNode = node\r\n    }\r\n    if(row < grid.length-1 && grid[row+1][col] !== true && grid[row+1][col].distance > node.distance + 1){\r\n        grid[row+1][[col]].distance = node.distance + 1\r\n        grid[row+1][col].parentNode = node\r\n    }\r\n    if(col > 0 && grid[row][col-1] !== true && grid[row][col-1].distance > node.distance + 1){\r\n        grid[row][col-1].distance = node.distance + 1\r\n        grid[row][col-1].parentNode = node\r\n    }\r\n    if(col < grid[0].length-1 && grid[row][col+1] !== true && grid[row][col+1].distance > node.distance + 1){\r\n        grid[row][col+1].distance = node.distance + 1\r\n        grid[row][col+1].parentNode = node\r\n    }\r\n}\r\n\r\nfunction findPath(finishNode){\r\n    let temp = []\r\n    while(finishNode.isStart !== true){\r\n        temp.push(finishNode.parentNode)\r\n        finishNode = finishNode.parentNode\r\n    }\r\n    return temp.reverse()\r\n}"]},"metadata":{},"sourceType":"module"}