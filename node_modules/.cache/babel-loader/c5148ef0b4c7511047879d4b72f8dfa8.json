{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\YASH\\\\path-find-visualizer\\\\src\\\\mycomponents\\\\PathFindingVisualizer.js\";\nimport React, { Component } from 'react';\nimport Node from './Node';\nimport { dijkstra } from '../algorithms/dijkstra';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst START_NODE_ROW = 8;\nconst START_NODE_COL = 20;\nconst FINISH_NODE_ROW = 5;\nconst FINISH_NODE_COL = 30;\nexport default class PathFindVisualizer extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      grid: [],\n      mousePressed: false\n    };\n  }\n\n  onStartNode() {}\n\n  componentDidMount() {\n    const grid = this.createGrid();\n    this.setState({\n      grid\n    });\n  }\n\n  handleMouseDown(row, col) {\n    const newGrid = creatGridWallToglled(this.state.grid, row, col);\n    this.setState({\n      grid: newGrid,\n      mousePressed: true\n    });\n  }\n\n  handleMouseEnter(row, col) {\n    if (this.state.mousePressed) {\n      const newGrid = creatGridWallToglled(this.state.grid, row, col);\n      this.setState({\n        grid: newGrid\n      });\n    }\n  }\n\n  handleMouseUp(row, col) {\n    this.setState({\n      mousePressed: false\n    });\n  }\n\n  animateDijkstra(visitedNodes, path) {\n    for (let i = 0; i <= visitedNodes.length; i++) {\n      if (i === visitedNodes.length) {\n        setTimeout(() => {\n          this.animateShortestPath(path);\n        }, 10 * i);\n        return;\n      }\n\n      setTimeout(() => {\n        const node = visitedNodes[i];\n        const newGrid = this.state.grid.slice();\n        const newNode = { ...node,\n          isVisited: true\n        };\n        newGrid[node.row][node.col] = newNode;\n        this.setState({\n          grid: newGrid\n        });\n      }, 10 * i);\n    }\n  }\n\n  animateShortestPath(path) {\n    for (let j = 0; j < path.length; j++) {\n      setTimeout(() => {\n        const node = path[j];\n        const newGrid = this.state.grid.slice();\n        const newNode = { ...node,\n          isVisited: false,\n          isInPath: true\n        };\n        newGrid[node.row][node.col] = newNode;\n        this.setState({\n          grid: newGrid\n        });\n      }, 25 * j);\n    }\n  }\n\n  visualizeDijkstra() {\n    const {\n      grid\n    } = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    const [visitedNodes, path] = dijkstra(grid, startNode, finishNode);\n    let grid1 = this.refreshGrid();\n    this.setState({\n      grid: grid1\n    });\n    this.animateDijkstra(visitedNodes, path);\n  }\n\n  refreshGrid() {\n    const newGrid = this.state.grid.slice();\n\n    for (let row = 0; row < this.props.i; row++) {\n      for (let col = 0; col < this.props.j; col++) {\n        let node = newGrid[row][col];\n        const currentNode = { ...node,\n          isVisited: false\n        };\n        newGrid[row][col] = currentNode;\n      }\n    }\n\n    return newGrid;\n  }\n\n  createGrid() {\n    let grid = [];\n\n    for (let row = 0; row < this.props.i; row++) {\n      let currentRow = [];\n\n      for (let col = 0; col < this.props.j; col++) {\n        let currentNode = {\n          row,\n          col,\n          isStart: row === START_NODE_ROW && col === START_NODE_COL,\n          isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n          distance: Infinity,\n          isWall: false,\n          isInPath: false,\n          isVisited: false,\n          parentNode: null\n        };\n        currentRow.push(currentNode);\n      }\n\n      grid.push(currentRow);\n    }\n\n    return grid;\n  }\n\n  render() {\n    const {\n      grid\n    } = this.state;\n    let align = {\n      textAlign: \"center\",\n      fontSize: \"0\"\n    };\n    return /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => this.visualizeDijkstra(),\n        children: \" Visualize Dijkstra's Algorithm\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 139,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: align,\n        className: \"my-3\",\n        children: grid.map((row, rowIdx) => {\n          return /*#__PURE__*/_jsxDEV(\"div\", {\n            children: row.map((node, nodeIdx) => {\n              const {\n                row,\n                isStart,\n                isFinish,\n                isVisited,\n                isInPath,\n                isWall,\n                col\n              } = node;\n              return /*#__PURE__*/_jsxDEV(Node, {\n                row: row,\n                col: col,\n                isStart: isStart,\n                isFinish: isFinish,\n                isWall: isWall,\n                isVisited: isVisited,\n                isInPath: isInPath,\n                onMouseDown: (row, col) => this.handleMouseDown(row, col),\n                onMouseUp: (row, col) => this.handleMouseUp(row, col),\n                onMouseEnter: (row, col) => this.handleMouseEnter(row, col)\n              }, nodeIdx, false, {\n                fileName: _jsxFileName,\n                lineNumber: 146,\n                columnNumber: 27\n              }, this);\n            })\n          }, rowIdx, false, {\n            fileName: _jsxFileName,\n            lineNumber: 143,\n            columnNumber: 22\n          }, this);\n        })\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 140,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true);\n  }\n\n}\n\nconst creatGridWallToglled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  console.log(newGrid);\n  const node = newGrid[row][col];\n  const newNode = { ...node,\n    isWall: !node.isWall\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};","map":{"version":3,"sources":["C:/Users/YASH/path-find-visualizer/src/mycomponents/PathFindingVisualizer.js"],"names":["React","Component","Node","dijkstra","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","PathFindVisualizer","constructor","props","state","grid","mousePressed","onStartNode","componentDidMount","createGrid","setState","handleMouseDown","row","col","newGrid","creatGridWallToglled","handleMouseEnter","handleMouseUp","animateDijkstra","visitedNodes","path","i","length","setTimeout","animateShortestPath","node","slice","newNode","isVisited","j","isInPath","visualizeDijkstra","startNode","finishNode","grid1","refreshGrid","currentNode","currentRow","isStart","isFinish","distance","Infinity","isWall","parentNode","push","render","align","textAlign","fontSize","map","rowIdx","nodeIdx","console","log"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\r\nimport Node from './Node';\r\nimport { dijkstra } from '../algorithms/dijkstra';\r\nconst START_NODE_ROW = 8;\r\nconst START_NODE_COL = 20;\r\nconst FINISH_NODE_ROW = 5;\r\nconst FINISH_NODE_COL = 30;\r\n\r\nexport default class PathFindVisualizer extends Component {\r\n    constructor(props){\r\n        super(props);\r\n        this.state = {\r\n            grid:[],\r\n            mousePressed:false,\r\n        };\r\n    }\r\n\r\n    onStartNode(){\r\n\r\n    }\r\n\r\n    componentDidMount(){\r\n        const grid = this.createGrid()\r\n        this.setState({grid})\r\n    }\r\n\r\n    handleMouseDown(row,col){\r\n        const newGrid = creatGridWallToglled(this.state.grid,row,col)\r\n        this.setState({grid:newGrid,mousePressed:true})\r\n    }\r\n\r\n    handleMouseEnter(row,col){\r\n        if(this.state.mousePressed){\r\n            const newGrid = creatGridWallToglled(this.state.grid,row,col)\r\n            this.setState({grid:newGrid})\r\n        }\r\n    }\r\n\r\n    handleMouseUp(row,col){\r\n        this.setState({mousePressed:false})\r\n    }\r\n\r\n    animateDijkstra(visitedNodes,path){\r\n        for(let i=0;i<=visitedNodes.length;i++){\r\n            if(i===visitedNodes.length){\r\n                setTimeout(()=>{\r\n                    this.animateShortestPath(path)\r\n                },10*i)\r\n                return\r\n            }\r\n            setTimeout(()=>{\r\n             const node = visitedNodes[i]\r\n         const newGrid = this.state.grid.slice();\r\n         const newNode = {\r\n             ...node,\r\n             isVisited:true\r\n         };\r\n         newGrid[node.row][node.col] = newNode\r\n             this.setState({grid:newGrid});\r\n            },10* i);\r\n        }\r\n       }\r\n\r\n    animateShortestPath(path){\r\n        for(let j =0;j<path.length;j++){\r\n            setTimeout(()=>{\r\n                const node = path[j]\r\n                const newGrid = this.state.grid.slice();\r\n                const newNode = {\r\n                    ...node,\r\n                    isVisited:false,\r\n                    isInPath:true\r\n                };\r\n                newGrid[node.row][node.col] = newNode\r\n                    this.setState({grid:newGrid});\r\n\r\n        },25*j)\r\n       }\r\n    }\r\n\r\n    visualizeDijkstra(){\r\n       const {grid} = this.state\r\n       const startNode = grid[START_NODE_ROW][START_NODE_COL]\r\n       const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL]\r\n       const [visitedNodes,path] = dijkstra(grid,startNode,finishNode)\r\n       let grid1 = this.refreshGrid()\r\n       this.setState({grid:grid1})\r\n       this.animateDijkstra(visitedNodes,path)\r\n       \r\n    }\r\n\r\n    refreshGrid(){\r\n        const newGrid = this.state.grid.slice()\r\n        for (let row = 0; row < this.props.i; row++) {\r\n            for (let col = 0; col < this.props.j; col++) {\r\n                let node = newGrid[row][col]\r\n                const currentNode = {\r\n                    ...node,\r\n                    isVisited:false\r\n                }\r\n                newGrid[row][col] = currentNode\r\n            }\r\n        }\r\n        return newGrid\r\n    }\r\n\r\n    createGrid(){\r\n        let grid = []\r\n        for (let row = 0; row < this.props.i; row++) {\r\n            let currentRow = []\r\n            for (let col = 0; col < this.props.j; col++) {\r\n                let currentNode = {\r\n                    row,\r\n                    col,\r\n                    isStart:row===START_NODE_ROW && col===START_NODE_COL,\r\n                    isFinish:row===FINISH_NODE_ROW && col===FINISH_NODE_COL,\r\n                    distance:Infinity,\r\n                    isWall:false,\r\n                    isInPath:false,\r\n                    isVisited:false,\r\n                    parentNode:null\r\n                }\r\n                currentRow.push(currentNode)\r\n            }\r\n            grid.push(currentRow)\r\n        }\r\n        return grid\r\n    }\r\n    \r\n\r\n    render(){\r\n        const {grid} = this.state;\r\n        let align = {\r\n            textAlign:\"center\",\r\n            fontSize:\"0\"\r\n        }\r\n        return(\r\n        <>\r\n        <button onClick={()=>this.visualizeDijkstra()}> Visualize Dijkstra's Algorithm</button>\r\n        <div style={align} className=\"my-3\">\r\n        {\r\n          grid.map((row,rowIdx)=>{\r\n              return <div key={rowIdx}>\r\n                  {row.map((node,nodeIdx) => {\r\n                  const {row,isStart,isFinish,isVisited,isInPath,isWall,col} = node\r\n                  return (<Node key={nodeIdx} \r\n                    row={row}\r\n                    col={col}\r\n                    isStart={isStart} \r\n                    isFinish={isFinish} \r\n                    isWall={isWall}\r\n                    isVisited={isVisited} \r\n                    isInPath={isInPath} \r\n                    onMouseDown={(row,col)=>this.handleMouseDown(row,col)}\r\n                    onMouseUp={(row,col)=>this.handleMouseUp(row,col)}\r\n                    onMouseEnter={(row,col)=>this.handleMouseEnter(row,col)}>\r\n                     </Node>)\r\n                  })}\r\n              </div>\r\n          })\r\n        }\r\n        </div>\r\n        </>\r\n        );\r\n    }\r\n}\r\n\r\nconst creatGridWallToglled = (grid,row,col) => {\r\n    const newGrid = grid.slice()\r\n    console.log(newGrid)\r\n    const node = newGrid[row][col]\r\n    const newNode = {\r\n        ...node,\r\n        isWall:!node.isWall,\r\n    };\r\n    newGrid[row][col] = newNode\r\n    return newGrid\r\n}\r\n"]},"metadata":{},"sourceType":"module"}