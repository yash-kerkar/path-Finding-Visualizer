{"ast":null,"code":"export function dijkstra(grid, startNode_row, startNode_col, finishNode_row, finishNode_col) {\n  grid[startNode_row][startNode_col].distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  let i = 0;\n\n  while (i < unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    updateNeighbours(unvisitedNodes[0], grid);\n    unvisitedNodes = unvisitedNodes.shift();\n  }\n}\n\nfunction getAllNodes(grid) {\n  let temp = [];\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (!grid[i][j].isVisited) {\n        temp.push(grid[i][j]);\n      }\n    }\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateNeighbours(node, grid) {\n  const {\n    row,\n    col\n  } = node;\n\n  if (row > 0 && grid[row - 1][col].distance > node.distance + 1) {\n    grid[row - 1][col].distance = node.distance + 1;\n  }\n\n  if (row < grid.length && grid[row + 1][col].distance > node.distance + 1) {\n    grid[row + 1][[col]].distance = node.distance + 1;\n  }\n\n  if (col > 0 && grid[row][col - 1].distance > node.distance + 1) {\n    grid[row][col - 1].distance = node.distance + 1;\n  }\n\n  if (col < grid[0].length && grid[row][col + 1].distance > node.distance + 1) {\n    grid[row][col + 1].distance = node.distance + 1;\n  }\n}","map":{"version":3,"sources":["C:/Users/YASH/path-find-visualizer/src/algorithms/dijkstra.js"],"names":["dijkstra","grid","startNode_row","startNode_col","finishNode_row","finishNode_col","distance","unvisitedNodes","getAllNodes","i","length","sortNodesByDistance","updateNeighbours","shift","temp","j","isVisited","push","sort","nodeA","nodeB","node","row","col"],"mappings":"AAAA,OAAO,SAASA,QAAT,CAAkBC,IAAlB,EAAuBC,aAAvB,EAAqCC,aAArC,EAAmDC,cAAnD,EAAkEC,cAAlE,EAAiF;AACpFJ,EAAAA,IAAI,CAACC,aAAD,CAAJ,CAAoBC,aAApB,EAAmCG,QAAnC,GAA8C,CAA9C;AACA,QAAMC,cAAc,GAAGC,WAAW,CAACP,IAAD,CAAlC;AACA,MAAIQ,CAAC,GAAG,CAAR;;AACA,SAAMA,CAAC,GAAGF,cAAc,CAACG,MAAzB,EAAgC;AAC5BC,IAAAA,mBAAmB,CAACJ,cAAD,CAAnB;AACAK,IAAAA,gBAAgB,CAACL,cAAc,CAAC,CAAD,CAAf,EAAmBN,IAAnB,CAAhB;AACAM,IAAAA,cAAc,GAAGA,cAAc,CAACM,KAAf,EAAjB;AACH;AAEJ;;AAED,SAASL,WAAT,CAAqBP,IAArB,EAA0B;AACtB,MAAIa,IAAI,GAAG,EAAX;;AACA,OAAI,IAAIL,CAAC,GAAC,CAAV,EAAaA,CAAC,GAAGR,IAAI,CAACS,MAAtB,EAA8BD,CAAC,EAA/B,EAAkC;AAC9B,SAAI,IAAIM,CAAC,GAAC,CAAV,EAAaA,CAAC,GAAEd,IAAI,CAACQ,CAAD,CAAJ,CAAQC,MAAxB,EAAgCK,CAAC,EAAjC,EAAoC;AAChC,UAAG,CAACd,IAAI,CAACQ,CAAD,CAAJ,CAAQM,CAAR,EAAWC,SAAf,EAAyB;AACrBF,QAAAA,IAAI,CAACG,IAAL,CAAUhB,IAAI,CAACQ,CAAD,CAAJ,CAAQM,CAAR,CAAV;AACH;AACJ;AACJ;AACJ;;AAED,SAASJ,mBAAT,CAA6BJ,cAA7B,EAA4C;AACxCA,EAAAA,cAAc,CAACW,IAAf,CAAoB,CAACC,KAAD,EAAOC,KAAP,KAAeD,KAAK,CAACb,QAAN,GAAiBc,KAAK,CAACd,QAA1D;AACH;;AAED,SAASM,gBAAT,CAA0BS,IAA1B,EAA+BpB,IAA/B,EAAoC;AAChC,QAAM;AAACqB,IAAAA,GAAD;AAAKC,IAAAA;AAAL,MAAYF,IAAlB;;AACA,MAAGC,GAAG,GAAG,CAAN,IAAWrB,IAAI,CAACqB,GAAG,GAAC,CAAL,CAAJ,CAAYC,GAAZ,EAAiBjB,QAAjB,GAA4Be,IAAI,CAACf,QAAL,GAAgB,CAA1D,EAA4D;AACxDL,IAAAA,IAAI,CAACqB,GAAG,GAAC,CAAL,CAAJ,CAAYC,GAAZ,EAAiBjB,QAAjB,GAA4Be,IAAI,CAACf,QAAL,GAAgB,CAA5C;AACH;;AACD,MAAGgB,GAAG,GAAGrB,IAAI,CAACS,MAAX,IAAqBT,IAAI,CAACqB,GAAG,GAAC,CAAL,CAAJ,CAAYC,GAAZ,EAAiBjB,QAAjB,GAA4Be,IAAI,CAACf,QAAL,GAAgB,CAApE,EAAsE;AAClEL,IAAAA,IAAI,CAACqB,GAAG,GAAC,CAAL,CAAJ,CAAY,CAACC,GAAD,CAAZ,EAAmBjB,QAAnB,GAA8Be,IAAI,CAACf,QAAL,GAAgB,CAA9C;AACH;;AACD,MAAGiB,GAAG,GAAG,CAAN,IAAWtB,IAAI,CAACqB,GAAD,CAAJ,CAAUC,GAAG,GAAC,CAAd,EAAiBjB,QAAjB,GAA4Be,IAAI,CAACf,QAAL,GAAgB,CAA1D,EAA4D;AACxDL,IAAAA,IAAI,CAACqB,GAAD,CAAJ,CAAUC,GAAG,GAAC,CAAd,EAAiBjB,QAAjB,GAA4Be,IAAI,CAACf,QAAL,GAAgB,CAA5C;AACH;;AACD,MAAGiB,GAAG,GAAGtB,IAAI,CAAC,CAAD,CAAJ,CAAQS,MAAd,IAAwBT,IAAI,CAACqB,GAAD,CAAJ,CAAUC,GAAG,GAAC,CAAd,EAAiBjB,QAAjB,GAA4Be,IAAI,CAACf,QAAL,GAAgB,CAAvE,EAAyE;AACrEL,IAAAA,IAAI,CAACqB,GAAD,CAAJ,CAAUC,GAAG,GAAC,CAAd,EAAiBjB,QAAjB,GAA4Be,IAAI,CAACf,QAAL,GAAgB,CAA5C;AACH;AACJ","sourcesContent":["export function dijkstra(grid,startNode_row,startNode_col,finishNode_row,finishNode_col){\r\n    grid[startNode_row][startNode_col].distance = 0;\r\n    const unvisitedNodes = getAllNodes(grid);\r\n    let i = 0;\r\n    while(i < unvisitedNodes.length){\r\n        sortNodesByDistance(unvisitedNodes);\r\n        updateNeighbours(unvisitedNodes[0],grid)\r\n        unvisitedNodes = unvisitedNodes.shift()\r\n    }\r\n\r\n}\r\n\r\nfunction getAllNodes(grid){\r\n    let temp = []\r\n    for(let i=0; i < grid.length; i++){\r\n        for(let j=0; j <grid[i].length; j++){\r\n            if(!grid[i][j].isVisited){\r\n                temp.push(grid[i][j])\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes){\r\n    unvisitedNodes.sort((nodeA,nodeB)=>nodeA.distance - nodeB.distance)\r\n}\r\n\r\nfunction updateNeighbours(node,grid){\r\n    const {row,col} = node;\r\n    if(row > 0 && grid[row-1][col].distance > node.distance + 1){\r\n        grid[row-1][col].distance = node.distance + 1;\r\n    }\r\n    if(row < grid.length && grid[row+1][col].distance > node.distance + 1){\r\n        grid[row+1][[col]].distance = node.distance + 1\r\n    }\r\n    if(col > 0 && grid[row][col-1].distance > node.distance + 1){\r\n        grid[row][col-1].distance = node.distance + 1\r\n    }\r\n    if(col < grid[0].length && grid[row][col+1].distance > node.distance + 1){\r\n        grid[row][col+1].distance = node.distance + 1\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}