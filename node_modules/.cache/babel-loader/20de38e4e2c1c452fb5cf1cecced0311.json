{"ast":null,"code":"export function dijkstra(grid, startNode, finishNode) {\n  console.log(finishNode);\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  let i = 0;\n\n  while (i < unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const minNode = unvisitedNodes.shift();\n    if (minNode.distance === Infinity) return [visitedNodesInOrder, null];\n    if (minNode.isWall || minNode.isBorder) continue;\n    minNode.isVisited = true;\n    visitedNodesInOrder.push(minNode);\n    console.log(finishNode);\n    if (minNode === finishNode) return [visitedNodesInOrder, findPath(finishNode)];\n    updateNeighbours(minNode, grid);\n  }\n}\n\nfunction getAllNodes(grid) {\n  let temp = [];\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (!grid[i][j].isVisited) {\n        temp.push(grid[i][j]);\n      }\n    }\n  }\n\n  return temp;\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateNeighbours(node, grid) {\n  const {\n    row,\n    col\n  } = node;\n\n  if (row > 0 && grid[row - 1][col].isVisited !== true && grid[row - 1][col].distance > node.distance + 1) {\n    grid[row - 1][col].distance = node.distance + 1;\n    grid[row - 1][col].parentNode = node;\n  }\n\n  if (row < grid.length - 1 && grid[row + 1][col] !== true && grid[row + 1][col].distance > node.distance + 1) {\n    grid[row + 1][[col]].distance = node.distance + 1;\n    grid[row + 1][col].parentNode = node;\n  }\n\n  if (col > 0 && grid[row][col - 1] !== true && grid[row][col - 1].distance > node.distance + 1) {\n    grid[row][col - 1].distance = node.distance + 1;\n    grid[row][col - 1].parentNode = node;\n  }\n\n  if (col < grid[0].length - 1 && grid[row][col + 1] !== true && grid[row][col + 1].distance > node.distance + 1) {\n    grid[row][col + 1].distance = node.distance + 1;\n    grid[row][col + 1].parentNode = node;\n  }\n}\n\nfunction findPath(finishNode) {\n  let temp = [];\n\n  while (finishNode.isStart !== true) {\n    temp.push(finishNode.parentNode);\n    finishNode = finishNode.parentNode;\n  }\n\n  return temp.reverse();\n}","map":{"version":3,"sources":["C:/Users/YASH/path-find-visualizer/src/algorithms/dijkstra.js"],"names":["dijkstra","grid","startNode","finishNode","console","log","visitedNodesInOrder","distance","unvisitedNodes","getAllNodes","i","length","sortNodesByDistance","minNode","shift","Infinity","isWall","isBorder","isVisited","push","findPath","updateNeighbours","temp","j","sort","nodeA","nodeB","node","row","col","parentNode","isStart","reverse"],"mappings":"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","sourcesContent":["\r\nexport function dijkstra(grid,startNode,finishNode){\r\n    console.log(finishNode)\r\n    const visitedNodesInOrder = []\r\n    startNode.distance = 0\r\n    const unvisitedNodes = getAllNodes(grid);\r\n    let i = 0;\r\n    while(i < unvisitedNodes.length){\r\n        sortNodesByDistance(unvisitedNodes);\r\n        const minNode = unvisitedNodes.shift()\r\n        if(minNode.distance === Infinity) return [visitedNodesInOrder,null]\r\n        if(minNode.isWall || minNode.isBorder) continue\r\n        minNode.isVisited = true\r\n        visitedNodesInOrder.push(minNode)\r\n        console.log(finishNode)\r\n        if(minNode === finishNode) return [visitedNodesInOrder,findPath(finishNode)]\r\n        updateNeighbours(minNode,grid)\r\n    }\r\n\r\n}\r\n\r\nfunction getAllNodes(grid){\r\n    let temp = []\r\n    for(let i=0; i < grid.length; i++){\r\n        for(let j=0; j <grid[i].length; j++){\r\n            if(!grid[i][j].isVisited){\r\n                temp.push(grid[i][j])\r\n            }\r\n        }\r\n    }\r\n    return temp\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes){\r\n    unvisitedNodes.sort((nodeA,nodeB)=>nodeA.distance - nodeB.distance)\r\n}\r\n\r\nfunction updateNeighbours(node,grid){\r\n    const {row,col} = node;\r\n    if(row > 0 && grid[row-1][col].isVisited !== true && grid[row-1][col].distance > node.distance + 1){\r\n        grid[row-1][col].distance = node.distance + 1;\r\n        grid[row-1][col].parentNode = node\r\n    }\r\n    if(row < grid.length-1 && grid[row+1][col] !== true && grid[row+1][col].distance > node.distance + 1){\r\n        grid[row+1][[col]].distance = node.distance + 1\r\n        grid[row+1][col].parentNode = node\r\n    }\r\n    if(col > 0 && grid[row][col-1] !== true && grid[row][col-1].distance > node.distance + 1){\r\n        grid[row][col-1].distance = node.distance + 1\r\n        grid[row][col-1].parentNode = node\r\n    }\r\n    if(col < grid[0].length-1 && grid[row][col+1] !== true && grid[row][col+1].distance > node.distance + 1){\r\n        grid[row][col+1].distance = node.distance + 1\r\n        grid[row][col+1].parentNode = node\r\n    }\r\n}\r\n\r\nfunction findPath(finishNode){\r\n    let temp = []\r\n    while(finishNode.isStart !== true){\r\n        temp.push(finishNode.parentNode)\r\n        finishNode = finishNode.parentNode\r\n    }\r\n    return temp.reverse()\r\n}"]},"metadata":{},"sourceType":"module"}